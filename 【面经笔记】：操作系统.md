# 【面经笔记】：操作系统

## 操作系统引论

### 操作系统的特性：

1. 并发：同一段时间内多个程序执行
2. 共享：系统中的资源可以被内存中多个并发执行的进线程共同使用
3. 虚拟：通过时分复用以及空分复用（如虚拟内存），把一个物理实体虚拟为多个
4. 异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进

### 操作系统的主要功能：

1. 进程管理：主要是对处理机进行管理，为了提高CPU的利用率而采用多道程序技术。通过进程管理来协调多道程序之间的关系，使得CPU得到充分利用。
2. 内存管理：适用于多任务系统（例如Windows），在同一时刻可能有多个应用程序共享内存，为了使得某个任务更好的执行，系统可能会对其他任务分配的内存进行移动，甚至删除。
3. 设备管理：管理所有外围设备，包括完成用户IO请求，为用户进程分配IO设备，提高IO设备利用率，提高IO速度，方便IO使用。
4. 文件管理：管理用户文件和系统文件，方便使用的同时保证安全性。包括磁盘存储空间管理，目录管理，文件读写管理以及文件共享及保护。
5. 提供用户接口：程序接口（如API）和用户接口（如GUI）

### 各种操作系统的区别：

1. 批处理操作系统：成批处理，系统吞吐量高，资源利用率高，用户不能干预作业的执行
2. 分时操作系统：多路性，独立性，及时性，交互性
3. 实时操作系统：及时响应，快速处理，高可靠性和安全性，不要求系统资源利用率

## 

## 进程和线程

### 进程和线程的定义，以及它们的区别：

1. 进程是**具有一定独立功能的程序关于某个数据集合上的一次运行活动**，是**系统进行资源分配和调度的一个独立单位**
2. 线程是进程的一个实体，是**CPU调度和分派的基本单位**，它是比进程更小的能独立运行的基本单位
3. 一个进程可以有多个线程，多个线程可以并发运行
4. 线程基本不拥有系统资源，只拥有一些在运行中必不可少的资源，比如程序计数器，寄存器和栈
5. 线程可以与其他线程共享进程所拥有的全部资源
6. 线程可以创建和撤销另一个线程

### 协程

又称微线程，是一种用户态（非特权状态）的轻量级线程

优点：

1. 无需线程上下文切换的开销
2. 无需原子操作锁定以及同步的开销（拥有自己的寄存器上下文和栈，所以也无法使用多核CPU）
3. 方便切换控制流，简化编程模型

**高并发+高扩展性+低成本：很适合用于高并发处理**

缺点：

1. 无法利用多核资源：协程本质上是个单线程，不能同时将单个CPU的多个核用上，协程需要和进程配合才能运行在多CPU上（多核CPU 是多个单核CPU的替代方案，多核CPU减小了体积，同时也减小了功耗，一个单个CPU上的核心只能同时执行一个线程）
2. 进行阻塞操作时会阻塞掉整个程序

### 用户态和核心态

运行在用户态下的程序，只能受限的访问内存，不允许访问外围设备，占用CPU的能力被剥夺，CPU资源可以被其他程序获取。

运行在内核态下的程序，可以访问内存所有数据，包括外围设备。

用户态切换到内核态的三种方式：

1. 系统调用：用户态进程主动要求切换到内核态的一种方式。用户态进程通过系统调用，申请使用操作系统提供的服务，以完成工作
2. 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，会触发由当前运行进程切换到处理异常的内核相关程序中。因此也就转到了内核态，比如缺页异常。
3. 外围设备终端：外围设备完成用户请求的操作后，会向CPU发送相应的中断信号。此时，CPU会暂停执行下一条即将要执行的指令，转而执行与中断信号对应的处理程序。如果先前主席那个的指令是用户态的程序，那么转换的过程自然就发生了由用户态到内核态的转换。

### 程序和进程的区别

1. 程序是一个静态概念，进程是一个动态概念
2. 程序没有并行特征，而进程有并行特征
3. 程序不会竞争计算机系统资源，而进程是竞争计算机系统资源的基本单位
4. 不同的进程可以包含同一程序，只要该程序所对应的数据集不同，即使用不同数据集的进程才可以执行同一程序

### 多线程共享什么数据

- 进程代码段
- 进程的公有数据
- 进程打开的文件描述符
- 信号的处理器
- 进程的当前目录
- 进程用户ID 与进程组ID

下面是另一种解释：

之前提到的共享数据指的是共享的环境

- 堆：由于堆是在进程空间中开辟出来的，所以理所当然被共享（16位平台上分全局堆和局部堆，局部堆是独享的）
- 全局变量：它是与具体某一函数无关的，所以也与特定线程无关，因此也是共享的
- 静态变量：虽然对于局部变量来说，它在代码中“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss 和.data 段，是共享的
- 文件等公共资源：这个是共享的，使用这些公共资源的线程必须同步。

### 线程同步的方式

1. 信号量：允许同一时刻多个线程访问同一个资源，但是需要控制同一时刻访问此资源的最大线程数量
2. 互斥量：实际上信号量的一种特殊情况，允许同一时刻只有一个线程访问同一个资源
3. 信号：也叫“事件”，通过通知操作的方式来保证多线程的同步，还可以方便实现多线程优先级的比较操作

### 多线程锁实现多线程同步

1. 互斥锁：保护临界区，确保同一时间，只有一个线程访问数据，如果互斥量已经上锁，调用线程会阻塞，直到互斥量被解锁
2. 自旋锁：在获取到锁之前，一直处于循环检测保持者是否已经释放了锁。与互斥锁的区别是，在申请自旋锁时，线程处于忙等状态，而非挂起状态
3. 信号量：一个计数器，用来控制多个进程对共享资源的访问。互斥锁为信号量的一个特殊情况
4. 读写锁：高级别锁，区分读和写，符合条件时，允许多个线程访问对象；处于读锁时，允许其他线程和本线程的读锁，但不允许写锁；处于写锁时，任何锁操作都会睡眠等待
5. 递归锁：递归锁是互斥锁的一个特殊情况。同样的，只能有一个线程访问该对象，但是允许同一个线程在未释放其拥有的锁时，反复对锁进行加锁操作

### 死锁及其产生的条件

在两个或者多个并发进程中，如果每个进程持有某种资源，又等待其他进程释放它目前持有的资源，在未改变这种状态之前，都不能向前推进。这一情况被称为“死锁”。

死锁产生的四个条件：

1. 互斥条件：一个资源一次只能被一个进程使用
2. 请求与保持条件：一个进程因请求资源而阻塞时，对其自身拥有的资源保持不放
3. 不可剥夺条件：进程获得资源，在未完全使用完之前，不能强行剥夺
4. 循环等待条件：若干进程之前形成一种头尾相接的环形等待资源关系

解决死锁的基本方法：

1. 预防死锁：确保死锁发生的四个必要条件中，至少有一个不成立
2. 避免死锁：动态检测资源分配状态，确保循环等待条件不成立，使系统处于安全状态
3. 解决死锁：包括进程终止和资源抢占
   - 选择一个牺牲品
   - 回滚
   - 饥饿（使回滚次数越多的，越不可能继续作为牺牲品）

### 进程的通信方式

1. 管道

   分为三种：普通管道PIPE，命名管道NAME_PIPE，流管道S_PIPE

   普通管道为双半工，只能单向传输，只能在父子进程间使用；流管道去除了第一种限制，可以双向传输；命名管道去除了第二种限制，可以在许多不相关的进程之间进行通讯

2. 系统IPC（包括消息队列，信号量，共享内存）

   信号量是一个计数器，用来控制多个进程对资源的访问，通常作为一个锁机制；消息队列是消息的链表，存放在内核中并由消息队列标识符标识；信号（也叫事件）是一种比较复杂的通信方式，用于通知接受进程某个事件已经发生；共享内存是映射一段能被其他进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。共享内存是最快的IPC（进程间通信）方式。

3. SOCKET

   套接口也试一种进程间的通信机制，它可用于不同主机间的进程通信

### 进程的状态

1. 就绪状态：进程已经获得了除处理机外的所需资源，正在等待分配处理机资源
2. 运行状态：占用处理机资源运行，处于此状态的进程数小于CPU数
3. 阻塞状态：进程等待某种条件，在条件满足之前无法执行

### 进程状态转换

1. 就绪 -- 运行：如，当前运行进程阻塞，调度程序选一个优先级最高的进程占有处理机
2. 运行 -- 就绪：如，当前运行进程时间片用完
3. 运行 -- 阻塞：如，当前运行进程等待键盘输入
4. 阻塞 -- 就绪：如，I/O 操作完成，被中断处理程序唤醒

### 线程的状态

1. 新建状态：当用new 操作符创建一个线程时，例如new Thread(r)， 线程还没有开始与西宁，此时线程处于新建状态。当一个线程处于新建状态时，程序还没有开始运行线程中的代码

2. 就绪状态：一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start() 方法。当线程对象调用start() 方法启动了线程，start() 方法创建线程运行的系统资源，并调用线程运行run() 方法。当start() 方法返回后，线程就处于就绪状态。

   处于就绪状态的线程不一定立即运行run() 方法，线程还必须同其他线程竞争CPU 时间，只有获得CPU 时间才可以运行线程。因为在单CPU 的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。

3. 运行状态：当线程获得CPU时间后，它才进入运行状态，真正开始执行run() 方法

4. 阻塞状态：指的是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU 时间，进入运行状态

5. 死亡状态：有两个原因会导致线程死亡（run 方法正常退出而自然死亡；一个未捕获的异常终止了run 方法而使线程猝死）

### 进程调度策略

先来先服务，短进程优先，优先级，时间片轮转，多级反馈

### 进程同步机制

信号量机制，自旋锁管程，会合，分布式系统

### 临界区

每个进程中，访问临界资源的那段程序块被称为临界区，每次只允许一个进程进入临界区，进入后不允许其他进程进入。

1. 若有若干进程要求进入空闲临界区，一次仅允许一个进程进入
2. 若已有进程进入临界区，其他进程必须等待
3. 进入临界区的进程必须在有限时间内退出
4. 如果进程不能进入临界区，则必须让出CPU

### 中断与轮询

中断指的是，在计算机执行期间，系统内发生任何非寻常或者非预期的急需处理事件，使得CPU 中断当前正在执行的程序，而转去执行相应的事件处理程序。处理完毕后，处理器又返回原来被中断的地方，继续执行或者调度新的进程

轮询指的是，系统定时对各种设备轮流询问一遍是否有处理要求。有要求的，则加以处理。轮询占据了CPU 相当一部分的处理时间，是一种效率较低的方式。

中断：容易遗漏一些问题，CPU 利用率高

轮询：效率低，等待时间长，CPU 利用率低

## 存储管理

### Windows 下的内存管理

Windows 提供了3种方法进行内存管理，分别为：

1. 虚拟内存，适用于管理大型对象或者结构数组
2. 内存映射文件，适用于管理大型数据流以及在单个计算机上运行多个进程之间的共享数据
3. 内存堆栈，适用于管理大量小对象

### 内存连续分配

1. 首次适应算法：空闲分区以地址递增次序连接，分配内存时顺序查找，找到大小能满足要求的第一个空闲分区
2. 最佳适应算法：空闲分区按照容量递增的次序连接，找到第一个能满足要求的空闲分区
3. 最坏适应算法：空闲分区以容量递减的次序连接，找到第一个能满足要求的空闲分区，也就是挑选最大的分区









