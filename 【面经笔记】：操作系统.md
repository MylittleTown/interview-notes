# 【面经笔记】：操作系统

## 操作系统引论

### 操作系统的特性：

1. 并发：同一段时间内多个程序执行
2. 共享：系统中的资源可以被内存中多个并发执行的进线程共同使用
3. 虚拟：通过时分复用以及空分复用（如虚拟内存），把一个物理实体虚拟为多个
4. 异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进

### 操作系统的主要功能：

1. 进程管理：主要是对处理机进行管理，为了提高CPU的利用率而采用多道程序技术。通过进程管理来协调多道程序之间的关系，使得CPU得到充分利用。
2. 内存管理：适用于多任务系统（例如Windows），在同一时刻可能有多个应用程序共享内存，为了使得某个任务更好的执行，系统可能会对其他任务分配的内存进行移动，甚至删除。
3. 设备管理：管理所有外围设备，包括完成用户IO请求，为用户进程分配IO设备，提高IO设备利用率，提高IO速度，方便IO使用。
4. 文件管理：管理用户文件和系统文件，方便使用的同时保证安全性。包括磁盘存储空间管理，目录管理，文件读写管理以及文件共享及保护。
5. 提供用户接口：程序接口（如API）和用户接口（如GUI）

### 各种操作系统的区别：

1. 批处理操作系统：成批处理，系统吞吐量高，资源利用率高，用户不能干预作业的执行
2. 分时操作系统：多路性，独立性，及时性，交互性
3. 实时操作系统：及时响应，快速处理，高可靠性和安全性，不要求系统资源利用率

## 

## 进程和线程

### 进程和线程的定义，以及它们的区别：

1. 进程是**具有一定独立功能的程序关于某个数据集合上的一次运行活动**，是**系统进行资源分配和调度的一个独立单位**
2. 线程是进程的一个实体，是**CPU调度和分派的基本单位**，它是比进程更小的能独立运行的基本单位
3. 一个进程可以有多个线程，多个线程可以并发运行
4. 线程基本不拥有系统资源，只拥有一些在运行中必不可少的资源，比如程序计数器，寄存器和栈
5. 线程可以与其他线程共享进程所拥有的全部资源
6. 线程可以创建和撤销另一个线程

### 协程

又称微线程，是一种用户态（非特权状态）的轻量级线程

优点：

1. 无需线程上下文切换的开销
2. 无需原子操作锁定以及同步的开销（拥有自己的寄存器上下文和栈，所以也无法使用多核CPU）
3. 方便切换控制流，简化编程模型

**高并发+高扩展性+低成本：很适合用于高并发处理**

缺点：

1. 无法利用多核资源：协程本质上是个单线程，不能同时将单个CPU的多个核用上，协程需要和进程配合才能运行在多CPU上（多核CPU 是多个单核CPU的替代方案，多核CPU减小了体积，同时也减小了功耗，一个单个CPU上的核心只能同时执行一个线程）
2. 进行阻塞操作时会阻塞掉整个程序

### 用户态和核心态

运行在用户态下的程序，只能受限的访问内存，不允许访问外围设备，占用CPU的能力被剥夺，CPU资源可以被其他程序获取。

运行在内核态下的程序，可以访问内存所有数据，包括外围设备。

用户态切换到内核态的三种方式：

1. 系统调用：用户态进程主动要求切换到内核态的一种方式。用户态进程通过系统调用，申请使用操作系统提供的服务，以完成工作
2. 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，会触发由当前运行进程切换到处理异常的内核相关程序中。因此也就转到了内核态，比如缺页异常。
3. 外围设备终端：外围设备完成用户请求的操作后，会向CPU发送相应的中断信号。此时，CPU会暂停执行下一条即将要执行的指令，转而执行与中断信号对应的处理程序。如果先前主席那个的指令是用户态的程序，那么转换的过程自然就发生了由用户态到内核态的转换。

### 程序和进程的区别

1. 程序是一个静态概念，进程是一个动态概念
2. 程序没有并行特征，而进程有并行特征
3. 程序不会竞争计算机系统资源，而进程是竞争计算机系统资源的基本单位
4. 不同的进程可以包含同一程序，只要该程序所对应的数据集不同，即使用不同数据集的进程才可以执行同一程序

### 多线程共享什么数据

- 进程代码段
- 进程的公有数据
- 进程打开的文件描述符
- 信号的处理器
- 进程的当前目录
- 进程用户ID 与进程组ID

下面是另一种解释：

之前提到的共享数据指的是共享的环境

- 堆：由于堆是在进程空间中开辟出来的，所以理所当然被共享（16位平台上分全局堆和局部堆，局部堆是独享的）
- 全局变量：它是与具体某一函数无关的，所以也与特定线程无关，因此也是共享的
- 静态变量：虽然对于局部变量来说，它在代码中“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss 和.data 段，是共享的
- 文件等公共资源：这个是共享的，使用这些公共资源的线程必须同步。

### 线程同步的方式

1. 信号量：允许同一时刻多个线程访问同一个资源，但是需要控制同一时刻访问此资源的最大线程数量
2. 互斥量：实际上信号量的一种特殊情况，允许同一时刻只有一个线程访问同一个资源
3. 信号：也叫“事件”，通过通知操作的方式来保证多线程的同步，还可以方便实现多线程优先级的比较操作

### 多线程锁实现多线程同步

1. 互斥锁：保护临界区，确保同一时间，只有一个线程访问数据，如果互斥量已经上锁，调用线程会阻塞，直到互斥量被解锁
2. 自旋锁：在获取到锁之前，一直处于循环检测保持者是否已经释放了锁。与互斥锁的区别是，在申请自旋锁时，线程处于忙等状态，而非挂起状态
3. 信号量：一个计数器，用来控制多个进程对共享资源的访问。互斥锁为信号量的一个特殊情况
4. 读写锁：高级别锁，区分读和写，符合条件时，允许多个线程访问对象；处于读锁时，允许其他线程和本线程的读锁，但不允许写锁；处于写锁时，任何锁操作都会睡眠等待
5. 递归锁：递归锁是互斥锁的一个特殊情况。同样的，只能有一个线程访问该对象，但是允许同一个线程在未释放其拥有的锁时，反复对锁进行加锁操作

### 死锁及其产生的条件

在两个或者多个并发进程中，如果每个进程持有某种资源，又等待其他进程释放它目前持有的资源，在未改变这种状态之前，都不能向前推进。这一情况被称为“死锁”。

死锁产生的四个条件：

1. 互斥条件：一个资源一次只能被一个进程使用
2. 请求与保持条件：一个进程因请求资源而阻塞时，对其自身拥有的资源保持不放
3. 不可剥夺条件：进程获得资源，在未完全使用完之前，不能强行剥夺
4. 循环等待条件：若干进程之前形成一种头尾相接的环形等待资源关系

解决死锁的基本方法：

1. 预防死锁：确保死锁发生的四个必要条件中，至少有一个不成立
2. 避免死锁：动态检测资源分配状态，确保循环等待条件不成立，使系统处于安全状态
3. 解决死锁：包括进程终止和资源抢占
   - 选择一个牺牲品
   - 回滚
   - 饥饿（使回滚次数越多的，越不可能继续作为牺牲品）

### 进程的通信方式

1. 管道

   分为三种：普通管道PIPE，命名管道NAME_PIPE，流管道S_PIPE

   普通管道为双半工，只能单向传输，只能在父子进程间使用；流管道去除了第一种限制，可以双向传输；命名管道去除了第二种限制，可以在许多不相关的进程之间进行通讯

2. 系统IPC（包括消息队列，信号量，共享内存）

   信号量是一个计数器，用来控制多个进程对资源的访问，通常作为一个锁机制；消息队列是消息的链表，存放在内核中并由消息队列标识符标识；信号（也叫事件）是一种比较复杂的通信方式，用于通知接受进程某个事件已经发生；共享内存是映射一段能被其他进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。共享内存是最快的IPC（进程间通信）方式。

3. SOCKET

   套接口也试一种进程间的通信机制，它可用于不同主机间的进程通信

### 进程的状态

1. 就绪状态：进程已经获得了除处理机外的所需资源，正在等待分配处理机资源
2. 运行状态：占用处理机资源运行，处于此状态的进程数小于CPU数
3. 阻塞状态：进程等待某种条件，在条件满足之前无法执行

### 进程状态转换

1. 就绪 -- 运行：如，当前运行进程阻塞，调度程序选一个优先级最高的进程占有处理机
2. 运行 -- 就绪：如，当前运行进程时间片用完
3. 运行 -- 阻塞：如，当前运行进程等待键盘输入
4. 阻塞 -- 就绪：如，I/O 操作完成，被中断处理程序唤醒

### 线程的状态

1. 新建状态：当用new 操作符创建一个线程时，例如new Thread(r)， 线程还没有开始与西宁，此时线程处于新建状态。当一个线程处于新建状态时，程序还没有开始运行线程中的代码

2. 就绪状态：一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start() 方法。当线程对象调用start() 方法启动了线程，start() 方法创建线程运行的系统资源，并调用线程运行run() 方法。当start() 方法返回后，线程就处于就绪状态。

   处于就绪状态的线程不一定立即运行run() 方法，线程还必须同其他线程竞争CPU 时间，只有获得CPU 时间才可以运行线程。因为在单CPU 的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。

3. 运行状态：当线程获得CPU时间后，它才进入运行状态，真正开始执行run() 方法

4. 阻塞状态：指的是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU 时间，进入运行状态

5. 死亡状态：有两个原因会导致线程死亡（run 方法正常退出而自然死亡；一个未捕获的异常终止了run 方法而使线程猝死）

### 进程调度策略

先来先服务，短进程优先，优先级，时间片轮转，多级反馈

### 进程同步机制

信号量机制，自旋锁管程，会合，分布式系统

### 临界区

每个进程中，访问临界资源的那段程序块被称为临界区，每次只允许一个进程进入临界区，进入后不允许其他进程进入。

1. 若有若干进程要求进入空闲临界区，一次仅允许一个进程进入
2. 若已有进程进入临界区，其他进程必须等待
3. 进入临界区的进程必须在有限时间内退出
4. 如果进程不能进入临界区，则必须让出CPU

### 中断与轮询

中断指的是，在计算机执行期间，系统内发生任何非寻常或者非预期的急需处理事件，使得CPU 中断当前正在执行的程序，而转去执行相应的事件处理程序。处理完毕后，处理器又返回原来被中断的地方，继续执行或者调度新的进程

轮询指的是，系统定时对各种设备轮流询问一遍是否有处理要求。有要求的，则加以处理。轮询占据了CPU 相当一部分的处理时间，是一种效率较低的方式。

中断：容易遗漏一些问题，CPU 利用率高

轮询：效率低，等待时间长，CPU 利用率低

## 存储管理

### Windows 下的内存管理

Windows 提供了3种方法进行内存管理，分别为：

1. 虚拟内存，适用于管理大型对象或者结构数组
2. 内存映射文件，适用于管理大型数据流以及在单个计算机上运行多个进程之间的共享数据
3. 内存堆栈，适用于管理大量小对象

### 内存连续分配

1. 首次适应算法：空闲分区以地址递增次序连接，分配内存时顺序查找，找到大小能满足要求的第一个空闲分区
2. 最佳适应算法：空闲分区按照容量递增的次序连接，找到第一个能满足要求的空闲分区
3. 最坏适应算法：空闲分区以容量递减的次序连接，找到第一个能满足要求的空闲分区，也就是挑选最大的分区

### 分页与分段的区别

段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址划分为若干段，如代码段，数据段，堆栈段。每个进程有一个二维地址空间，相互独立，互不打扰。

段式存储管理的优点是：没有内存碎片，因为段大小可变，可以通过改变段的大小而消除内存碎片。但会产生外碎片，比如4K的段换成5K的段，就会产生1K的外碎片。

页式存储管理是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页，而物理内存划分为同样大小的帧。程序加载时，可将任意一页放入内存中任意一帧，这些帧不必连续，从而实现了离散分离。

页式存储管理的优点是：没有外碎片，因为页的大小固定，但是会产生碎片，因为一个页可能填充不满

两者的不同点：

1. 目的不同：分页是由于系统管理的需要，是信息的物理单位。分段是由于用户的需要，是信息的逻辑单位。
2. 大小不同：页的大小固定，由系统决定；段的大小不固定，由其完成的功能决定
3. 地址空间不同：页向用户提供一维地址空间，段向用户提供二维地址空间
4. 信息共享：页的保护和共享受到限制，段利于存储保护和信息共享
5. 内存碎片：分页没有外碎片，但是有内碎片；分段没有内碎片，但有外碎片

### 基本分页储存管理方式

页表用于记录逻辑地址和实际存储地址之间的映射关系，以实现从页号到物理块号的映射。

访问分页系统中内存数据需要两次的内存。

1. 从内存中访问页表，找到指定的物理块号，加上页内偏移，得到实际物理地址
2. 根据第一次访问得到物理地址，访问内存，存取数据

### 基本分段存储管理方式

分段内存管理中，地址是二维的，其中一维为段号，另一维是段内地址。每个段的长度不一样，每个段内部都从0开始编址。

段内部为连续内存分配，但是段与段之间离散分配，因此有了段表机制，以从一个逻辑地址映射到一个物理地址。

### 缓冲区溢出及其危害

缓冲区溢出指的是，计算机向缓冲区填充数据时，超出了缓冲区本身的容量，溢出的数据覆盖在了合法的数据上。其危害有：

1. 程序崩溃，导致拒绝服务
2. 跳转并且执行一段恶意代码

造成缓冲区溢出的主要原因是因为程序中没有仔细检查用户输入

### 虚拟内存

虚拟内存允许执行进程不必完全在内存中

每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，成为页。每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有页都在内存里才能运行程序。

当程序引用到一部分在物理内存中的地址空间时，由硬件进行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，操作系统负责将缺失部分装入物理内存，并重新执行失败的指令

### 虚拟内存的应用与优点

1. 在内存中可以保留多个进程，系统并发度提高
2. 解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大

访问虚拟内存时，会访问到MMU（Memory Management Unit），去匹配对应的物理地址。如果内存已满，还会调用页面置换算法。

### 页面置换算法

1. FIFO，先进先出
2. LRU，last recently used，最近最少使用，根据使用时间到现在的长短判断
3. LFU，last frequently used，最近使用次数算法，根据使用次数来判断
4. OPT，optimal replacement，最优置换算法，保证置换出去的是不再被使用的页，或者在实际内存中最晚使用的

### 堆和栈的区别

程序的内存分配

1. 堆：由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收
2. 栈：由编译器自动分配释放，存放函数的参数值，局部变量的值等等
3. 全局区/静态区：
   1. 全局变量和静态变量是放在一起的
   2. 初始化的全局变量和静态变量放在一个区域
   3. 未初始化的全局变量和静态变量放在另一个区域
   4. 程序结束时由系统释放
4. 文字常量区：常量字符串的存放位置，由操作系统在程序结束后释放
5. 程序代码区：存放函数体的二进制代码

## 输入与输出

### 磁盘调度算法

- FCFS：先进先出
- SSTF：Short Seek Time First，最短寻道时间优先。可能会出现饥饿现象
- Elevator：向一个方向寻道，寻完后再向另一个方向寻道

### RAID磁盘阵列技术

- RAID 0
  - 需要两张以上的硬盘，可提高整个硬盘的性能和吞吐量
  - 无冗余或者错误修复能力，若一张硬盘丢失，则所有数据丢失
- RAID 1
  - 镜像，在主硬盘上存放数据时，也在镜像硬盘上写一样的数据。一张硬盘坏了，还有另外一张可以代替
  - RAID 1数据安全性最好，但是磁盘利用率低
- RAID 2
  - 至少需要三台磁盘驱动器。以汉明码的方式将数据编码后分区为独立的比特，将数据分别写入硬盘中
  - 加入了错误修正码ECC，数据整体容量会比原始数据大一些
- RAID 3
  - 采用数据交错存储技术
- RAID 4
  - 块交织技术
- RAID 5
  - 硬盘分区，储存性能，数据安全与存储成本兼顾
  - 需要至少三块硬盘，将数据和相对应的奇偶校验信息存储在组成RAID 5的各个磁盘上，并且奇偶校验信息和相对应的数据分别存储于不同磁盘上
  - 允许一块硬盘损坏
- RAID 6
  - 增加了第二个独立的奇偶校验信息块，数据可靠性非常高
  - 允许两块磁盘同时失效
  - 至少需要四块硬盘









